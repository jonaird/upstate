import 'dart:async';
import 'dart:collection';
import 'dart:convert';
import 'package:flutter/widgets.dart';
import '../upstate.dart';
import 'dart:math';

part 'maps.dart';
part 'state_list.dart';
part 'state_value.dart';

/// StateElement is the base class for everything in the state tree.
/// State elements are automatically generated by providing normal elements to [StateObject]

abstract class StateElement {
  final _StateIterable parent;
  bool _removedFromStateTree = false, notifyParent;
  StateElement Function(dynamic value, StateElement parent) converter;
  StateValueTyping typing;
  TypeSafety typeSafety;

  StateElement(this.parent) {
    if (parent != null) {
      notifyParent = parent.notifyParent;
      typing = parent.typing;
      converter = parent.converter;
      typeSafety = parent.typeSafety;
    }
  }

//uncomment to perform tests
  // @visibleForTesting
  // void removeFromStateTree() {
  //   _removeFromStateTree();
  // }
  final StreamController<StateElementNotification> _notifications =
      StreamController.broadcast();

  /// converts a state element to primitives before converting to json
  /// in [StateObject.fromJson(json)].
  dynamic toPrimitive();

  bool get isRoot => this is StateObject;

  ///Whether a state element has been removed from the state tree
  bool get removedFromStateTree => _removedFromStateTree;

  ///Returns a stream that can be subscribed to that receives [StateElementNotification]s
  /// either 'changed', 'instantiated' or 'removedFromStateTree'
  Stream<StateElementNotification> get notifications => _notifications.stream;

  StreamSubscription<StateElementNotification> subscribe(
      void Function(StateElementNotification notification) callback) {
    return notifications.listen((event) {
      callback(event);
    });
  }

  //Notifies all listeners that this element has changed and dependent widgets should rebuild.
  void notifyChange() {
    if (removedFromStateTree) {
      throw ('State element has been removed from the state tree and can\'t be modified');
    } else {
      _notifications.add(StateElementNotification.changed);
      if (notifyParent && !isRoot) {
        parent.notifyChange();
      }
    }
  }

  void _removeFromStateTree() {
    _notifications.add(StateElementNotification.removedFromStateTree);
    _notifications.close();

    //recursively removes children from tree;
    if (this is StateMap) {
      var map = this as StateMap;
      map.forEach((key, stateElement) {
        stateElement._removeFromStateTree();
      });
    } else if (this is StateList) {
      var list = this as StateList;
      list.forEach((stateElement) {
        stateElement._removeFromStateTree();
      });
    }
    _removedFromStateTree = true;
  }

  String toJson() {
    return jsonEncode(toPrimitive());
  }
}

///StatePath is a helper class that implements the list interface and represents a path in the state tree.
class StatePath<T> extends ListBase {
  List _path;
  final type = T;

  StatePath(List path) {
    for (var key in path) {
      if (!(key is int || key is String)) {
        throw ('StatePaths must contain only Strings or ints');
      }
    }
    _path = path;
  }

  factory StatePath.from(StatePath path) {
    return StatePath(path.toList());
  }

  int get length => _path.length;

  set length(int newLength) {
    _path.length = newLength;
  }

  dynamic operator [](int index) => _path[index];

  void operator []=(int index, value) {
    if (!(value is int || value is String)) {
      throw ('StatePaths must contain only Strings or ints');
    }
    _path[index] = value;
  }
}

//Notification that are sent to listeners when a state element changes
enum StateElementNotification { changed, instantiated, removedFromStateTree }

enum TypeSafety { unsafe, basic, complete }

StateElement _toStateElement(obj, StateElement parent) {
  if (parent != null && parent.converter != null) {
    StateElement elem = parent.converter(obj, parent);
    if (elem != null) {
      return elem;
    }
  }

  if (obj is List) {
    return StateList(obj, parent);
  } else if (obj is Map) {
    return StateMap(obj, parent);
  } else if (parent.typing == StateValueTyping.dynamicTyping) {
    return StateValue<dynamic>(obj, parent);
  } else {
    switch (obj.runtimeType) {
      case String:
        {
          return StateValue<String>(obj, parent);
        }

      case bool:
        {
          return StateValue<bool>(obj, parent);
        }

      case Null:
        {
          if (parent.typing == StateValueTyping.nonNullable) {
            return StateValue<Null>(obj, parent);
          } else {
            return StateValue<dynamic>(obj, parent);
          }
        }
        break;
      case int:
        {
          return StateValue<int>(obj, parent);
        }
        break;

      case double:
        {
          return StateValue<double>(obj, parent);
        }
        break;

      default:
        {
          throw ("All elements in the state tree must be of type double, int, bool, String, Map, List or null unless you set "
              "stronglyTyped:false or use a converter");
        }
    }
  }
}

abstract class _StateIterable extends StateElement {
  _StateIterable(_StateIterable parent) : super(parent);

  _getElementFromKey(key);

  dynamic _getElementFromPath(StatePath path) {
    dynamic element = this;

    for (var key in path) {
      if ((element is StateMap && key is String) ||
          (element is StateList && key is int)) {
        element = element?._getElementFromKey(key);
      } else {
        throw ('Invalid state path for state: $this');
      }
    }

    return element;
  }

  T call<T>(StatePath path) {
    if (typeSafety != TypeSafety.unsafe && path.type == dynamic) {
      //TODO: include article
      throw ('when using complete type safety all paths must have their expected state element types as '
          'their generic values. See this article for more info:');
    }

    var stateElement = _getElementFromPath(path);
    if (path.type != dynamic) {
      if (path.type == stateElement.runtimeType) {
        return stateElement;
      } else {
        throw ('Type error when trying to get state element at path: $path');
      }
    } else {
      return stateElement;
    }
  }

  void _instantiateNullWithValue(
      StateValue<Null> oldElement, StateValue newElement);
}

///This built in converter will convert all ints and doubles to [StateValue]<num>
StateValue numConverter(number, StateElement parent) {
  if (number is num) {
    return StateValue<num>(number, parent);
  } else {
    return null;
  }
}
